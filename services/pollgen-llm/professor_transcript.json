{
  "text": "Good morning students, today let's delve into the topic of greedy algorithms. \nThese are a class of algorithms that make locally optimal choices at each step with the hope of finding a global optimum. \nThey're often simpler and faster than other approaches, but they don’t always yield the best solution unless certain conditions are met.\n\nLet’s consider the classic example of the coin change problem, where the goal is to return change for a given amount using the fewest number of coins. \nIn countries like the US, where coin denominations are well-structured, a greedy approach works perfectly. \nBut in cases where denominations are irregular, greedy algorithms may fail to find the optimal solution.\n\nNow, to prove the correctness of a greedy algorithm, we typically rely on something called a 'greedy choice property' and 'optimal substructure'. \nThe greedy choice property means that a global optimum can be arrived at by selecting a local optimum. \nOptimal substructure means the problem can be broken down into smaller subproblems which can be solved optimally and independently.\n\nLet me walk you through an example — the Activity Selection problem. \nYou're given a list of activities with start and end times, and you need to schedule as many non-overlapping activities as possible. \nThe greedy solution involves always picking the activity that ends the earliest. \nThis ensures we leave as much room as possible for future activities, maximizing the count. \n\nTo prove this is correct, we often use an exchange argument. \nThat means, if we assume there’s a better schedule than ours, we can show that replacing one of its choices with ours doesn’t hurt the solution quality. \nEventually, through a series of exchanges, we end up with the greedy schedule, proving its optimality.\n\nGreedy algorithms are also used in Huffman coding, Dijkstra’s algorithm, Kruskal’s and Prim’s algorithms for finding Minimum Spanning Trees, and many scheduling problems.\n\nSo, remember, when facing a problem, always check if it satisfies greedy properties. \nIf it does, a greedy solution is often not only the simplest, but also the most efficient one.\n\nThat's all for today. In the next class, we'll discuss dynamic programming and contrast it with greedy strategies. Thank you.",
  "language": "English"
}